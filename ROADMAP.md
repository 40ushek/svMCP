# svMCP — Drawing Automation Roadmap

Цель: автоматическое приведение чертежей Tekla в читаемый вид —
разрешение конфликтов видов и аннотаций, подбор масштаба, сдвиг объектов.

## Статус реализации

### Готово ✅

| Инструмент | Описание |
|---|---|
| `check_connection` | Соединение с Tekla |
| `list_drawings` | Список всех чертежей |
| `find_drawings` | Поиск по имени / марке |
| `find_drawings_by_properties` | Поиск по фильтрам (name, mark, type, status) |
| `export_drawings_to_pdf` | Экспорт в PDF по GUID |
| `create_general_arrangement_drawing` | Создать GA-чертёж через макрос |
| `get_drawing_context` | Активный чертёж + выделенные объекты |
| `select_drawing_objects` | Выделить объекты по model ID |
| `filter_drawing_objects` | Фильтр объектов по типу (Mark, Part, DimensionBase…) |
| `set_mark_content` | Изменить содержимое и шрифт марок |

---

## Фаза 1 — Чтение геометрии чертежа

> **Приоритет: высокий.** Без этого невозможно обнаружение конфликтов.

### `get_drawing_views`
Получить все виды активного чертежа с их геометрией.

**Возвращает:**
```json
[
  {
    "id": 123,
    "name": "FRONT VIEW",
    "origin": { "x": 100.0, "y": 150.0 },
    "width": 400.0,
    "height": 300.0,
    "scale": 50.0,
    "type": "DetailView | SectionView | StandardView"
  }
]
```

**Tekla API:** `DrawingHandler.GetActiveDrawing().GetSheet().GetAllObjects()` → фильтр по `View`; `View.Origin`, `View.RestrictionBox`, `View.Attributes.Scale`.

---

### `get_drawing_objects_layout`
Получить bounding box всех аннотационных объектов (марки, размеры, тексты) в координатах листа.

**Возвращает:**
```json
[
  {
    "id": 456,
    "type": "Mark",
    "origin": { "x": 110.5, "y": 200.3 },
    "boundingBox": {
      "min": { "x": 108.0, "y": 198.0 },
      "max": { "x": 125.0, "y": 207.0 }
    },
    "viewId": 123
  }
]
```

**Сложность:** Tekla API возвращает `Origin` для большинства объектов, но `BoundingBox` — нужно проверить наличие через reflection или вычислять по размеру шрифта / количеству строк.

---

## Фаза 2 — Обнаружение конфликтов

### `detect_view_conflicts`
Найти виды, которые перекрываются на листе (пересечение bounding box-ов).

**Возвращает:** список пар `[viewId1, viewId2]` с координатами пересечения.

**Алгоритм:** AABB intersection для всех пар видов. O(n²), но видов обычно < 20.

---

### `detect_annotation_conflicts`
Найти марки / тексты / размеры, которые:
- перекрываются между собой
- перекрываются с рамкой вида
- выходят за пределы листа

**Возвращает:** список объектов с флагом типа конфликта.

---

## Фаза 3 — Редактирование видов

### `move_view`
Сдвинуть вид на листе.

**Параметры:** `viewId`, `dx`, `dy` (смещение в мм листа) или `newOrigin` (абсолютные координаты).

**Tekla API:** `view.Origin = new Point(x, y); view.Modify();`

---

### `set_view_scale`
Изменить масштаб вида.

**Параметры:** `viewId`, `scale` (например `50` для 1:50).

**Tekla API:** `view.Attributes.Scale = scale; view.Modify();`

**Нюанс:** после изменения масштаба размер вида на листе меняется — нужно пересчитать конфликты.

---

### `auto_fit_views`
Автоматически расставить виды без перекрытий.

**Алгоритм:**
1. Получить размер листа (`Sheet.Width`, `Sheet.Height`)
2. Отсортировать виды по размеру (большие — первыми)
3. Разместить жадным алгоритмом (strip packing или grid layout)
4. Сохранить отступы между видами (параметр `margin`, default 20мм)

**Ограничение:** не меняет масштаб — только двигает. Если не влезает, возвращает ошибку с рекомендацией уменьшить масштаб.

---

## Фаза 4 — Редактирование аннотаций

### `move_mark`
Сдвинуть марку.

**Параметры:** `markId`, `dx`, `dy` или `newOrigin`.

**Tekla API:** `mark.Origin = new Point(...); mark.Modify();`

---

### `auto_resolve_annotation_conflicts`
Автоматически разрешить конфликты марок.

**Алгоритм:**
1. Обнаружить конфликтующие пары через bounding box
2. Для каждой пары — сдвинуть одну марку по 8 стандартным направлениям (N, NE, E, SE…)
3. Выбрать направление с минимальным суммарным перемещением без новых конфликтов
4. Итерировать до разрешения или до `maxIterations`

**Ограничение:** Tekla не гарантирует что `BoundingBox` марки доступен — может потребоваться эвристика по тексту.

---

## Фаза 5 — Комплексная команда

### `tidy_drawing`
Одна команда для приведения активного чертежа в порядок.

**Режимы:**
- `analyze` — только отчёт о конфликтах, ничего не меняет
- `preview` — возвращает план изменений без применения
- `apply` — применяет изменения

**Параметры:**
```
mode: "analyze" | "preview" | "apply"
fixViews: bool       // двигать виды
fixAnnotations: bool // двигать марки
margin: float        // отступ между объектами (мм)
```

---

## Технические риски

| Риск | Вероятность | Обходной путь |
|---|---|---|
| `BoundingBox` объектов недоступен через API | Средняя | Вычислять из `Origin` + размер шрифта × длина текста |
| Виды с фиксированным положением (locked) | Низкая | Проверять флаг и пропускать |
| Марки с лидером меняют позицию непредсказуемо | Высокая | Двигать только марки без лидера или с коротким лидером |
| Макросы для GA не работают в Drawing mode | Низкая | Уже решено — макросы в `modeling/` |

---

## Порядок реализации

```
get_drawing_views
    ↓
get_drawing_objects_layout
    ↓
detect_view_conflicts + detect_annotation_conflicts
    ↓
move_view + set_view_scale
    ↓
move_mark
    ↓
auto_fit_views + auto_resolve_annotation_conflicts
    ↓
tidy_drawing
```

Каждый шаг тестируется отдельно перед переходом к следующему.
